1.  Which functions don't work with writing the '\n' character:
    a) printf("%c", '\n');  works
    b) printf("%c", "\n");  doesn't work, expected a char but given a string
    c) printf("%s", '\n');  doesn't work, expected a string but given a char
    d) printf("%s", "\n");  works
    e) printf('\n');        doesn't work, printf needs a string, not a char
    f) printf("\n");        works
    g) putchar('\n');       works
    h) putchar("\n");       doesn't work, putchar only works with chars
    i) puts('\n');          doesn't work, puts only works with strings
    j) puts("\n");          works
    k) puts("");            works

2.  Show the output and which of the following are legal and illegal for:
    char *p = "abc";
    a) putchar(p);      illegal, expected char but given a char pointer
    b) putchar(*p);     legal, output: a
    c) puts(p);         legal, output: abc
    d) puts(*p);        illegal, expected a string, but given a char

3.  What are the values of i (int), s (char *), j (int) from: scanf("%d%s%d", &i, s, &j);
    if the user put in: 12abc34 56def78
    i: 12, s: abc34, j: 56 

4.  int read_line(char str[], int n)
    {
        int ch, i = 0;

        while ((ch = getchar()) != '\n')
            if (i < n)
                str[i++] = ch;
        str[i] = '\0';
        return i;
    }
    Modify read_line to skip the whitespace at the beginning of the line
                        stop reading at the first white-space character
                        stop reading at the first newline character (and store it)
                        leave behind characters it can't store (break loop)

    int read_line(char str[], int n)
    {
        int ch, i = 0;
        bool stop_at_space = false;

        while ((ch = getchar()) != '\n')
        {
            if (stop_at_space && isspace(ch))
                break;
            else if (isspace(ch))
                continue;
            else if (i < n)
            {
                str[i++] = ch;
                stop_at_space = true;
            }
            else
                break;
        }

        str[i++] = '\n';
        str[i] = '\0';

        return i;
    }

5.  Write a function called 'capitalise' that converts all lowercase to uppercase.
    a) With array subscripting:
        void capitalise(char s[], int n)
        {
            int i;
            for (i = 0; i < n; i++)
                s[i] = toupper(s[i]);
        }

    b) With pointer arithmetic:
        void capitalise(char *s)
        {
            char *p;
            for (p = s; *p != '\0'; p++)
                *p = toupper(*p);
        }

6.  Write a function called censor where it replaces all instances of 'foo' with X's
    void censor(char *s, char *t)
    {
        char *p = t;
        int match = 0, length = 0;

        while (*p++ != '\0')
            length++;

        while (*s != '\0')
        {
            for (p = t, match = 0; *p != '\0'; p++)
                if (*(s+match) == *p)
                    match++;

            if (match == length)
                while (match-- > 0)
                    *s++ = 'X';
            else
                s++;
        }
    }

7.  str is an array of characters, which statement is not equivalent to the other three?
    a) *str = 0;
    b) str[0] = '\0';
    c) strcpy(str, "");
    d) strcat(str, "");

    'a' is not equivalent because it is setting the 0th element to 0 as an int, this does not add
    '\0' like the other statements.

8.  What is str after the statements:
    strcpy(str, "tire-bouchon");
    strcpy(&str[4], "d-or-wi');
    strcat(str, "red?");

    str: tire-bouchon
    str: tired-or-wi
    str: tired-or-wired?

9.  What is s1 after the statements:
    strcpy(s1, "computer");
    strcpy(s2, "science");
    if (strcmp(s1, s2) < 0)
        strcat(s1, s2);
    else
        strcat(s2, s1);
    s1[strlen(s1)-6] = '\0';

    s1: "computer"
    strcmp: s1 is less than s2
    s1: "computerscience"
    s1: "computer"

10. What's wrong with the function:
    char *duplicate(const char *p)
    {
        char *q;

        strcpy(q, p);
        return q;
    }

    the function is returning a local variable which gets deleted after the function runs.