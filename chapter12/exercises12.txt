1.                 p              q
    int a[] = {5, 15, 34, 54, 14, 2, 52, 72};
    int *p = &a[1], *q = &a[5];

    a) *(p+3)  is 54
    b) *(q-3)  is 34
    c) q-p     is 4
    d) p < q   is 1 - true
    e) *p < *q is 0 - false

2.  low, middle, high are pointers, low and high point to array elements, why isn't this legal?
    middle = (low + high) / 2;
    You can't add pointers together, only can minus them. To fix:

	int n = 7;
	high = &a[n];
	middle = high - (n / 2);

3.  Contents of 'a' after:
    #define N 10

    int a[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int *p = &a[0], *q = &a[N-1], temp;
    
    while (p < q)
    {
        temp = *p;
        *p++ = *q;
        *q-- = temp;
    }

    a is {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}

4.  Rewrite make_empty, is_empty, is_full from the stack example to use top_ptr instead of top:
    int a[N], *top_ptr = &a[N];

    void make_empty()
    {
        top_ptr = &a[0];
    }

    bool is_empty()
    {
        return top_ptr == &a[0];
    }

    bool is_full()
    {
        return top_ptr == &a[N];
    }