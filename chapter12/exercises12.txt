1.                 p              q
    int a[] = {5, 15, 34, 54, 14, 2, 52, 72};
    int *p = &a[1], *q = &a[5];

    a) *(p+3)  is 54
    b) *(q-3)  is 34
    c) q-p     is 4
    d) p < q   is 1 - true
    e) *p < *q is 0 - false

2.  low, middle, high are pointers, low and high point to array elements, why isn't this legal?
    middle = (low + high) / 2;
    You can't add pointers together, only can minus them. To fix:

	int n = 7;
	high = &a[n];
	middle = high - (n / 2);

3.  Contents of 'a' after:
    #define N 10

    int a[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int *p = &a[0], *q = &a[N-1], temp;
    
    while (p < q)
    {
        temp = *p;
        *p++ = *q;
        *q-- = temp;
    }

    a is {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}

4.  Rewrite make_empty, is_empty, is_full from the stack example to use top_ptr instead of top:
    int a[N], *top_ptr = &a[N];

    void make_empty()
    {
        top_ptr = &a[0];
    }

    bool is_empty()
    {
        return top_ptr == &a[0];
    }

    bool is_full()
    {
        return top_ptr == &a[N];
    }

5.  a is a one-dimensional array, p is a pointer. After p = a, which of the following are legal and
    which of those are true:
    a) p == a[0]     illegal, p is pointer and a[0] is not a pointer
    b) p == &a[0]    legal and evaluates to 1 (true)
    c) *p == a[0]    legal and evaluates to 1 (true)
    d) p[0] == a[0]  legal and evaluates to 1 (true)

6.  Rewrite the following function to use pointer arithmetic instead of array subscripting:
    int sum_array(const int a[], int n)
    {
        int i, sum;

        sum = 0;
        for (i = 0; i < n; i++)
            sum += a[i];
        return sum;
    }

    int sum_array2(const int a[], int n)
    {
        const int *p

        int sum = 0;
        for (p = a; p < a + n; p++)
            sum += *p;
        return sum;
    }

7.  Write the following function: bool search(const int a[], int n, int key);
    bool search(const int a[], int n, int key)
    {
        const int *p;
        for (p = a; p < a + n; p++)
            if (*p == key)
                return true;
                
        return false;
    }

8.  Rewrite the following function to use pointer arithmetic instead of array subscripting:
    void store_zeros(int a[], int n)
    {
        int i;
        for (i = 0; i < n; i++)
            a[i] = 0;
    }

    void store_zeros(int a[], int n)
    {
        int *p;
        for (p = a; p < a + n; p++)
            *p = 0;
    }